% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/icnet_flex.R
\name{fsnet_flex}
\alias{fsnet_flex}
\title{Elastic-net penalized flexible finite-support regression}
\usage{
fsnet_flex(
  M,
  Z,
  theta,
  lam = 1e-05,
  alpha = 0,
  pen_factor = NULL,
  box_constr = NULL,
  L = 10,
  maxit = rep(100, 3),
  tol = rep(1e-08, 2),
  method = "prox_newt",
  distr = "norm",
  verbose = FALSE,
  acc = TRUE
)
}
\arguments{
\item{M}{Matrix (\eqn{n \times 2}) of offsets.}

\item{Z}{Model matrix (\eqn{2n\times d}).}

\item{theta}{Vector (\eqn{d\times 1}) of initial iterates for parameter \eqn{\theta}.}

\item{lam}{Vector of penalty parameters \eqn{\lambda}.}

\item{alpha}{Scalar weight \eqn{\alpha} for elastic net (1 = lasso, 0 =
ridge).}

\item{pen_factor}{Vector (\eqn{d \times 1}) of coefficient-specific penalty
weights.}

\item{box_constr}{Matrix (\eqn{d \times 2}) of box constraints. Can be \code{-Inf}
(first col.) or \code{Inf} (second col.).}

\item{L}{Scalar setting step-size 1 / L if \code{method = "fista"}.}

\item{maxit}{Vector of maximum number of iterations. If \code{method =
"prox_newt"}, \code{maxit[1]} for Newton, \code{maxit[2]} for linesearch,
and \code{maxit[3]} for coordinate descent within each Newton step.}

\item{tol}{Vector of tolerances for terminating algorithm. If \code{method =
"prox_newt"}, \code{tol[1]} is for Newton and \code{tol[2]} for coordinate
descent within Newton.}

\item{method}{Method to use; \code{"fista"} or \code{"prox_newt"} (proximal
Newton).}

\item{distr}{Distribution function \eqn{R} (see details); \code{"ee"} for
extreme-value or \code{"norm"} for normal.}

\item{verbose}{Logical indicating whether additional information should be
printed during fitting.}

\item{acc}{Logical indicating whether to use acceleration if \code{method =
"fista"}.}
}
\value{
A list with components

\item{theta}{Matrix of estimates of \eqn{\theta}.}

\item{lam}{Vector of penalty parameters.}

\item{iter}{Vector of number of iterations performed for each element of
\code{lam}.}

\item{conv}{Vector with convergence diagnostics for each element of
\code{lam}: 0 means convergence, 1 means minimum was found on square root
tolerance but \code{maxit[1]} reached, 2 means \code{maxit[1]} reached
without finding minimum, and 3 means \code{maxit[1]} was not reached nor was
a minimum found.}

\item{obj}{Vector with reached objective value for each element of
\code{lam}.}

\item{loglik}{Vector with log-likelihood at final iterates for each element
of \code{lam}.}
}
\description{
{ Minimizes an elastic net-penalized negative log-likelihood for
finite-support response regression using accelerated proximal gradient
descent or proximal Newton.}
}
\details{
Denote the \eqn{i}th row of \code{M} by \eqn{M_i = (M_i^a, M_i^b)}.
Denote the first two rows of \code{Z} by \eqn{Z_1}, the next two rows by
\eqn{Z_2}, and so on. Denote the first row of \eqn{Z_i} by \eqn{z_i^a}
and the second by \eqn{z_i^b}.
The likelihood for the \eqn{i}th observation is, for a log-concave cdf
\eqn{R}, \deqn{R(b_i) - R(a_i),}

where \eqn{a_i = M_i^a + \theta' z_i^a } and \eqn{b_i =
M_i^b + \theta'z_i^b}.

With \eqn{P} denoting \code{pen_factor} and \eqn{\circ} the elementwise
product, the objective function minimized is \deqn{g(\theta; \lambda, \alpha,
P) = -\frac{1}{n}\sum_{i = 1}^n \log\{R(b_i) - R(a_i)\} + \alpha \lambda
\Vert P\circ \theta \Vert_1 + \frac{1}{2}(1 - \alpha)\lambda \Vert P\circ
\theta\Vert^2.}

WARNING: It is up to the user to ensure \eqn{b_i \geq a_i} for all feasible
\eqn{\theta} by using appropriate \code{Z} and \code{box_constr}. Thus, it
may be simpler to, if possible, use the functions \code{fsnet} and
\code{fsnet_cat} which handle two important special cases of
\code{fsnet_flex}.

If \code{method = "fista"}, then only the first elements of \code{maxit} and
\code{tol} are used. If \code{method = "prox_newt"}, then the first element
of \code{maxit} is the maximum number of Newton iterations, the second is the
maximum number of line search iterations for each Newton update, and the
third is the maximum number of coordinate descent iterations within each
Newton update. The first element of \code{tol} is for terminating the Newton
iterations and the second for terminating the coordinate descent updates
within each Newton iteration.
}
